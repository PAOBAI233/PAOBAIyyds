/**
 * èŒƒå¼è½¬æ¢å·¥ä½œå®¤æ™ºèƒ½é¤é¥®ç³»ç»Ÿ
 * ä¸»æœåŠ¡å™¨å…¥å£æ–‡ä»¶
 */

const express = require('express');
const http = require('http');
const socketIo = require('socket.io');
const cors = require('cors');
const helmet = require('helmet');
const compression = require('compression');
const morgan = require('morgan');
const rateLimit = require('express-rate-limit');
const path = require('path');
require('dotenv').config();

// å¯¼å…¥è·¯ç”±
const apiRoutes = require('./routes/api');
const customerRoutes = require('./routes/customer');
const kitchenRoutes = require('./routes/kitchen');
const adminRoutes = require('./routes/admin');

// å¯¼å…¥ä¸­é—´ä»¶
const errorHandler = require('./middleware/errorHandler');
const logger = require('./utils/logger');
const { initDatabase } = require('./database/init');

// åˆ›å»ºExpressåº”ç”¨
const app = express();
const server = http.createServer(app);

// é…ç½®Socket.IO
const io = socketIo(server, {
  cors: {
    origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],
    methods: ['GET', 'POST'],
    credentials: true
  }
});

// åŸºç¡€ä¸­é—´ä»¶
app.use(helmet({
  crossOriginResourcePolicy: { policy: "cross-origin" }
});
app.use(compression());
app.use(morgan('combined', { stream: { write: message => logger.info(message.trim()) } }));

// CORSé…ç½®
app.use(cors({
  origin: process.env.CORS_ORIGIN?.split(',') || ['http://localhost:3000'],
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization'],
  credentials: true
});

// é™æµé…ç½®
const limiter = rateLimit({
  windowMs: (process.env.RATE_LIMIT_WINDOW || 15) * 60 * 1000, // 15åˆ†é’Ÿ
  max: process.env.RATE_LIMIT_MAX || 100, // é™åˆ¶æ¯ä¸ªIP 100ä¸ªè¯·æ±‚
  message: {
    success: false,
    message: 'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•'
  }
});
app.use('/api', limiter);

// è§£æJSONå’Œè¡¨å•æ•°æ®
app.use(express.json({ limit: '10mb' });
app.use(express.urlencoded({ extended: true, limit: '10mb' });

// é™æ€æ–‡ä»¶æœåŠ¡
app.use('/uploads', express.static(path.join(__dirname, 'uploads')));
app.use('/static', express.static(path.join(__dirname, 'public')));

// è·¯ç”±é…ç½®
app.use('/api', apiRoutes);
app.use('/customer', customerRoutes);
app.use('/kitchen', kitchenRoutes);
app.use('/admin', adminRoutes);

// å¥åº·æ£€æŸ¥ç«¯ç‚¹
app.get('/health', (req, res) => {
  res.json({
    success: true,
    message: 'ç³»ç»Ÿè¿è¡Œæ­£å¸¸',
    timestamp: new Date().toISOString(),
    version: '1.0.0'
  });
});

// ä¸»é¡µè·¯ç”±
app.get('/', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// 404å¤„ç†
app.use('*', (req, res) => {
  res.status(404).json({
    success: false,
    message: 'æ¥å£ä¸å­˜åœ¨'
  });
});

// é”™è¯¯å¤„ç†ä¸­é—´ä»¶
app.use(errorHandler);

// Socket.IO è¿æ¥å¤„ç†
const activeConnections = new Map();
const socketAuth = require('./middleware/socketAuth');

io.use(socketAuth);

io.on('connection', (socket) => {
  const userId = socket.user?.id || socket.id;
  const userType = socket.user?.type || 'anonymous';
  
  logger.info(`ç”¨æˆ·è¿æ¥: ${userId} (${userType})`);
  
  // å­˜å‚¨è¿æ¥ä¿¡æ¯
  activeConnections.set(userId, {
    socketId: socket.id,
    userType,
    connectedAt: new Date(),
    lastActivity: new Date()
  });

  // åŠ å…¥é¤å…æˆ¿é—´
  if (socket.user?.restaurantId) {
    socket.join(`restaurant_${socket.user.restaurantId}`);
  }

  // åŠ å…¥æ¡Œå°æˆ¿é—´
  if (socket.user?.sessionId) {
    socket.join(`session_${socket.user.sessionId}`);
  }

  // å¤„ç†å®æ—¶è®¢å•æ›´æ–°
  socket.on('order_update', (data) => {
    const { orderId, status, sessionId } = data;
    
    // å¹¿æ’­ç»™åŒä¸€ä¼šè¯çš„ç”¨æˆ·
    if (sessionId) {
      io.to(`session_${sessionId}`).emit('order_status_update', {
        orderId,
        status,
        timestamp: new Date().toISOString()
      });
    }

    // å¹¿æ’­ç»™åå¨
    io.to(`restaurant_${socket.user?.restaurantId}`).emit('new_order', {
      orderId,
      status,
      timestamp: new Date().toISOString()
    });
  });

  // å¤„ç†åŠ å…¥æ¡Œå°
  socket.on('join_session', (sessionId) => {
    socket.join(`session_${sessionId}`);
    socket.leave(`session_${socket.user?.sessionId}`);
    socket.user.sessionId = sessionId;
    logger.info(`ç”¨æˆ· ${userId} åŠ å…¥ä¼šè¯ ${sessionId}`);
  });

  // å¤„ç†ç¦»å¼€æ¡Œå°
  socket.on('leave_session', (sessionId) => {
    socket.leave(`session_${sessionId}`);
    logger.info(`ç”¨æˆ· ${userId} ç¦»å¼€ä¼šè¯ ${sessionId}`);
  });

  // å¤„ç†æ”¯ä»˜çŠ¶æ€æ›´æ–°
  socket.on('payment_update', (data) => {
    const { sessionId, status, amount } = data;
    
    // å¹¿æ’­ç»™åŒä¸€ä¼šè¯çš„æ‰€æœ‰ç”¨æˆ·
    io.to(`session_${sessionId}`).emit('payment_status_update', {
      status,
      amount,
      timestamp: new Date().toISOString()
    });
  });

  // å¤„ç†åå¨è®¢å•çŠ¶æ€æ›´æ–°
  socket.on('kitchen_order_update', (data) => {
    const { orderId, status, sessionId } = data;
    
    // å¹¿æ’­ç»™åŒä¸€ä¼šè¯çš„ç”¨æˆ·
    if (sessionId) {
      io.to(`session_${sessionId}`).emit('order_status_update', {
        orderId,
        status,
        timestamp: new Date().toISOString()
      });
    }
  });

  // å¿ƒè·³æ£€æµ‹
  socket.on('ping', () => {
    const connection = activeConnections.get(userId);
    if (connection) {
      connection.lastActivity = new Date();
    }
    socket.emit('pong', { timestamp: new Date().toISOString() });
  });

  // æ–­å¼€è¿æ¥å¤„ç†
  socket.on('disconnect', () => {
    logger.info(`ç”¨æˆ·æ–­å¼€è¿æ¥: ${userId} (${userType})`);
    activeConnections.delete(userId);
    
    // é€šçŸ¥å…¶ä»–ç”¨æˆ·è¯¥ç”¨æˆ·ç¦»çº¿
    if (socket.user?.sessionId) {
      socket.to(`session_${socket.user.sessionId}`).emit('user_offline', {
        userId,
        timestamp: new Date().toISOString()
      });
    }
  });

  // é”™è¯¯å¤„ç†
  socket.on('error', (error) => {
    logger.error(`Socketé”™è¯¯ [${userId}]:`, error);
  });
});

// å®šæœŸæ¸…ç†éæ´»è·ƒè¿æ¥
setInterval(() => {
  const now = new Date();
  const timeout = 5 * 60 * 1000; // 5åˆ†é’Ÿè¶…æ—¶
  
  activeConnections.forEach((connection, userId) => {
    if (now - connection.lastActivity > timeout) {
      const socket = io.sockets.sockets.get(connection.socketId);
      if (socket) {
        socket.disconnect(true);
      }
      activeConnections.delete(userId);
      logger.info(`æ¸…ç†éæ´»è·ƒè¿æ¥: ${userId}`);
    }
  });
}, 60000); // æ¯åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡

// å¯¼å‡ºioå®ä¾‹ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
app.set('io', io);

// å¯åŠ¨æœåŠ¡å™¨
const PORT = process.env.PORT || 3000;
const HOST = process.env.HOST || 'localhost';

async function startServer() {
  try {
    // åˆå§‹åŒ–æ•°æ®åº“
    logger.info('æ­£åœ¨åˆå§‹åŒ–æ•°æ®åº“...');
    await initDatabase();
    logger.info('æ•°æ®åº“åˆå§‹åŒ–å®Œæˆ');

    // å¯åŠ¨æœåŠ¡å™¨
    server.listen(PORT, HOST, () => {
      logger.info(`ğŸš€ æœåŠ¡å™¨å¯åŠ¨æˆåŠŸ`);
      logger.info(`ğŸ“ åœ°å€: http://${HOST}:${PORT}`);
      logger.info(`ğŸŒ ç¯å¢ƒ: ${process.env.NODE_ENV || 'development'}`);
      logger.info(`â° æ—¶é—´: ${new Date().toLocaleString('zh-CN')}`);
      
      // æ‰“å°æœ‰ç”¨çš„è·¯ç”±ä¿¡æ¯
      console.log('\nğŸ“‹ å¯ç”¨ç«¯ç‚¹:');
      console.log('  ğŸ  ä¸»é¡µ: http://' + HOST + ':' + PORT + '/');
      console.log('  ğŸ›¡ï¸  å¥åº·æ£€æŸ¥: http://' + HOST + ':' + PORT + '/health');
      console.log('  ğŸ”§ APIæ–‡æ¡£: http://' + HOST + ':' + PORT + '/api');
      console.log('  ğŸ½ï¸  é¡¾å®¢ç«¯: http://' + HOST + ':' + PORT + '/customer');
      console.log('  ğŸ‘¨â€ğŸ³ åå¨ç«¯: http://' + HOST + ':' + PORT + '/kitchen');
      console.log('  âš™ï¸  ç®¡ç†ç«¯: http://' + HOST + ':' + PORT + '/admin');
      console.log('');
    });

  } catch (error) {
    logger.error('æœåŠ¡å™¨å¯åŠ¨å¤±è´¥:', error);
    process.exit(1);
  }
}

// ä¼˜é›…å…³é—­å¤„ç†
process.on('SIGTERM', () => {
  logger.info('æ”¶åˆ°SIGTERMä¿¡å·ï¼Œæ­£åœ¨å…³é—­æœåŠ¡å™¨...');
  server.close(() => {
    logger.info('æœåŠ¡å™¨å·²å…³é—­');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  logger.info('æ”¶åˆ°SIGINTä¿¡å·ï¼Œæ­£åœ¨å…³é—­æœåŠ¡å™¨...');
  server.close(() => {
    logger.info('æœåŠ¡å™¨å·²å…³é—­');
    process.exit(0);
  });
});

// æœªæ•è·çš„å¼‚å¸¸å¤„ç†
process.on('uncaughtException', (error) => {
  logger.error('æœªæ•è·çš„å¼‚å¸¸:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('æœªå¤„ç†çš„Promiseæ‹’ç»:', reason);
  process.exit(1);
});

// å¯åŠ¨æœåŠ¡å™¨
startServer();

module.exports = { app, server, io };